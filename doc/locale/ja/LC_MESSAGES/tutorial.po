# Japanese translations for groonga storage engine package.
# Copyright (C) 2009-2011, groonga project
# This file is distributed under the same license as the groonga storage engine package.
# Kouhei Sutou <kou@clear-code.com>, 2011.
#
msgid ""
msgstr ""
"Project-Id-Version: groonga storage engine 1.0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-06-05 11:36+0900\n"
"PO-Revision-Date: 2014-06-05 11:37+0900\n"
"Last-Translator: Kouhei Sutou <kou@clear-code.com>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid "Tutorial"
msgstr "チュートリアル"

msgid ""
"If you don't install Mroonga yet, see :doc:`install`. It describes how to "
"install Mroonga."
msgstr ""
"まだMroongaをインストールしていない場合は :doc:`install` を参照してください。"
"そのドキュメントでMroongaのインストール方法を説明しています。"

msgid ""
"Try the following tutorials after you install Mroonga. You will understand "
"how to use Mroonga."
msgstr ""
"Mroongaをインストールしたら次のチュートリアルを試してください。Mroongaの使い"
"方がわかります。"

msgid "Installation check"
msgstr "インストールチェック"

msgid ""
"It is better that you check Mroonga installation before you use Mroonga. If "
"Mroonga installation is failed, the SQLs in this tutorial will fail."
msgstr ""
"Mroongaを使う前にMroongaのインストールチェックをした方がよいです。もし、"
"Mroongaのインストールに失敗していると、このチュートリアルででてくるSQLが失敗"
"してしまいます。"

msgid "The way to start or stop MySQL server is just same as the normal MySQL."
msgstr "MySQLサーバの起動停止方法は通常のMySQLと同じです。"

msgid ""
"After invoking the MySQL server, connect to it by mysql command. If you set "
"password, you need to add '-p' option. ::"
msgstr ""
"MySQLサーバを起動した上でmysqlコマンドで接続します。パスワードを設定済みの場"
"合は ``-p`` オプションでパスワードを指定して下さい。 ::"

msgid ""
"By using SHOW ENGINES command, you can check if mroonga is installed. ::"
msgstr ""
"SHOW ENGINESコマンドでmroongaがインストールされているかどうかを確認します。::"

msgid ""
"If you see \"mroonga\" storage engine like above, the installation is well "
"done."
msgstr ""
"上記のように\"mroonga\"ストレージエンジンが見えていればインストールは無事完了"
"しています。"

msgid "If not installed, invoke INSTALL PLUGIN command like below. ::"
msgstr ""
"インストールされていなければ以下のようにINSTALL PLUGINコマンドを実行して下さ"
"い。 ::"

msgid "Mode"
msgstr "モード"

msgid "Mroonga has the following two modes."
msgstr "Mroongaには以下の2つのモードがあります。"

msgid "storage mode"
msgstr "ストレージモード"

msgid "wrapper mode"
msgstr "ラッパーモード"

msgid ""
"With the storage mode, we use Groonga for both of the full text search "
"function and the data storage. Since all functions of storage engine are "
"realised with Groonga, aggregations are fast, that is one of Groonga's "
"advantages, and you can manage the database directly by ``groonga`` command."
msgstr ""
"ストレージモードでは、全文検索機能だけではなくデータストアも含めてGroongaの機"
"能を利用します。ストレージエンジンのすべての機能をGroongaで実現するため、"
"Groongaが得意としている集計操作が高速です。また、 ``groonga`` コマンドで直接"
"データベースを操作できるという特長もあります。"

msgid ""
"The structure of the storage mode is the following. You use it instead of "
"existing storage engines like MyISAM or InnoDB"
msgstr ""
"ストレージモードの構成を図で表すと以下のようになります。MyISAMやInnoDBなど既"
"存のストレージエンジンの代わりに利用します。"

msgid ""
"With the wrapper mode, Groonga is used for full text search function only, "
"and another existing storage engine like InnoDB is used for storing data. By "
"using wrapper mode, you combine InnoDB that is well-use as the storage "
"engine and Mroonga that is a proven full text search engine, and you can use "
"it as the stable database having the fast full text search function."
msgstr ""
"ラッパーモードでは全文検索機能のみGroongaの機能を利用し、データストアはInnoDB"
"など既存のストレージエンジンを利用します。ラッパーモードを利用することによ"
"り、ストレージエンジンとして多くの利用実績のあるInnoDBに全文検索エンジンとし"
"て実績のあるMroongaを組み合わせて、高速な全文検索機能付きの信頼性のあるデータ"
"ベースとして利用できるという特長があります。"

msgid ""
"The structure of the wrapper mode is the following. Full text search related "
"operations are done by Mroonga, and other operations are done by existing "
"storage engines like MyISAM, InnoDB etc. Mroonga is located between SQL "
"Handler that processes SQL and an existing storage engine, thus all data "
"goes through Mroonga With this way, full text search indexing etc. are done "
"transparently."
msgstr ""
"ラッパーモードの構成を図で表すと以下のようになります。全文検索関連の処理は"
"Mroongaで処理し、それ以外の処理はMyISAMやInnoDBなど既存のストレージエンジンを"
"利用します。SQLを処理するSQL Handlerと既存のストレージエンジンの間に位置する"
"ため、すべてのデータが一度Mroongaを通ることになります。これを利用して、全文検"
"索用のインデックス作成などを透過的に行います。"

msgid "Storage mode"
msgstr "ストレージモード"

msgid "Here we explain how to use storage mode of Mroonga"
msgstr "ここでは Mroonga におけるストレージモードの利用方法を説明します。"

msgid "How to use full text search"
msgstr "全文検索の利用方法"

msgid ""
"After confirming the installation, let's create a table. The important point "
"is to specify Mroonga by ``ENGINE = Mroonga``. ::"
msgstr ""
"インストールが確認できたら、テーブルを1つ作成してみましょう。 ``ENGINE = "
"Mroonga`` とMroongaを指定するところがポイントです。::"

msgid "We put data by INSERT. ::"
msgstr "INSERTでデータを投入してみましょう。 ::"

msgid "Try full text search. ::"
msgstr "全文検索を実行してみます。 ::"

msgid "Yes, full text search works."
msgstr "おぉぉー。検索できましたね。"

msgid "How to get search score"
msgstr "検索スコアの取得方法"

msgid ""
"In version 1.0.0 or before, Mroonga used a special column named ``_score`` "
"to get search score. From version 1.0.0, it follows MySQL's standard way to "
"get search score."
msgstr ""
"1.0.0以前のMroongaではMySQLの標準的な検索スコアの取得方法ではなく、 "
"``_score`` という専用のカラムを作成するという独自の方法でした。1.0.0からは"
"MySQLの標準的な取得方法になっています。"

msgid ""
"We often want to display more relevant results first in full text search. We "
"use search score in such case."
msgstr ""
"全文検索を行う際、指定したキーワードにより内容が一致するレコードを上位に表示"
"したいというような場合があります。そうしたケースでは検索スコアを利用します。"

msgid ""
"We can get search score by MySQL's standard way [#score]_, i.e. we use "
"MATCH...AGAINST in one of columns in SELECT or ORDER BY."
msgstr ""
"検索スコアはMySQLの標準的な方法 [#score]_ で取得できます。つまり、SELECTの取"
"得するカラム名を指定するところやORDER BYのところにMATCH...AGAINSTを指定しま"
"す。"

msgid "Let's try. ::"
msgstr "それでは実際にやってみましょう。::"

msgid ""
"The result having the search word ``fine`` more, i.e. ``id = 3`` message "
"having the higher search score, is displayed first. And you also get search "
"score by using MATCH AGAINST in SELECT phrase."
msgstr ""
"検索対象の文字列 ``晴れ`` をより多く含む、すなわち検索スコアの高い ``id = "
"3`` のメッセージが上に来ていることが確認できます。また、SELECT句にMATCH "
"AGAINSTを記述しているため、検索スコアも取得できています。"

msgid "You can use ``AS`` to change the attribute name. ::"
msgstr "属性名を変更したい場合は ``AS`` を使って下さい。 ::"

msgid "How to specify the parser for full text search"
msgstr "全文検索用パーサの変更"

msgid ""
"MySQL has the following syntax to specify the parser [#parser]_ for full "
"text search. ::"
msgstr ""
"MySQLは全文検索用のパーサ [#parser]_ を指定する以下のような構文を持っていま"
"す。::"

msgid ""
"To use this syntax, you need to register all parsers in MySQL beforehand. On "
"the other hand, Groonga can dynamically add a tokenizer, that is a parser in "
"MySQL. So if use this syntax in Mroonga, tokenizers that are added in "
"Groonga dynamically cannot be supported. We think that this limitation "
"decreases the convenience, and we choose our own syntax using COMMENT like "
"the following. ::"
msgstr ""
"しかし、この構文を利用する場合は、あらかじめすべてのパーサをMySQLに登録してお"
"く必要があります。一方、Groongaはトークナイザー（MySQLでいうパーサ）を動的に"
"追加することができます。そのため、Mroongaでもこの構文を採用するとGroonga側に"
"動的に追加されたトークナイザーに対応できなくなります。Groongaに動的に追加され"
"るトークナイザーにはMeCabを用いたトークナイザーもあり、この制限に縛られること"
"は利便性を損なうと判断し、以下のようなコメントを用いた独自の構文を採用するこ"
"とにしました。::"

msgid ""
"``COMMENT`` in ``FULLTEXT INDEX`` is only supported MySQL 5.5 or later. If "
"you use MySQL 5.1, use ``mroonga_default_parser`` variable described below."
msgstr ""
"``FULLTEXT INDEX`` に ``COMMENT`` を指定できるのはMySQL 5.5からになります。"
"MySQL 5.1を利用している場合は後述の ``mroonga_default_parser`` 変数を利用して"
"ください。"

msgid "You can specify one of following values as the parser."
msgstr "パーサに指定できるのは以下の値です。"

msgid ""
"It does not tokenize at all. Use \"off\" if you want to treat ``content`` as "
"is. For example, this value is used for prefix search."
msgstr ""
"トークナイズしません。\"off\"は``content``をそのまま扱いたい場合に使います。"
"例えば、この値は前方一致検索のために指定します。"

msgid "off"
msgstr ""

msgid ""
"It tokenises in bigram. But continuous alphabets, numbers or symbols are "
"treated as a token. So there can exist tokes with 3 letters or more. It is "
"to reduce noises."
msgstr ""
"バイグラムでトークナイズする。ただし、連続したアルファベット・連続した数字・"
"連続した記号はそれぞれ1つのトークンとして扱う。そのため、3文字以上のトークン"
"も存在する。これはノイズを減らすためである。"

msgid "This is the default value."
msgstr "デフォルト値。"

msgid "TokenBigram"
msgstr ""

msgid "It tokenises using MeCab. Groonga should be built with MeCab support."
msgstr ""
"MeCabを用いてトークナイズする。groongaがMeCabサポート付きでビルドされている必"
"要がある。"

msgid "TokenMecab"
msgstr ""

msgid ""
"It tokenises in bigram. Unlike TokenBigram, continuous symbols are not "
"treated as a token, but tokenised in bigram."
msgstr ""
"バイグラムでトークナイズする。TokenBigramと異なり、記号が連続していても特別扱"
"いして1つのトークンとして扱わず通常のバイグラムの処理を行う。"

msgid "TokenBigramSplitSymbol"
msgstr ""

msgid ""
"When you use TokenBigramSplitSymbol instead of TokenBigram, \"!?\" can match "
"\"!?!?!?\" in \"Is it really!?!?!?\". But when you use TokenBigram, only "
"\"!?!?!?\" can match as well."
msgstr ""
"TokenBigramではなくTokenBigramSplitSymbolを利用すると「Is it really!?!?!?」の"
"「!?!?!?」の部分に「!?」でマッチする。TokenBigramの場合は「!?!?!?」でないと"
"マッチしない。"

msgid ""
"It tokenise in bigram. In addition to TokenBigramSplitSymbol, continuous "
"alphabets are not treated as a token either, but tokenised in bigram."
msgstr ""
"バイグラムでトークナイズする。TokenBigramSplitSymbolに加えて、連続したアル"
"ファベットも特別扱いせずに通常のバイグラムの処理を行う。"

msgid "TokenBigramSplitSymbolAlpha"
msgstr ""

msgid ""
"When you use TokenBigramSplitSymbolAlpha instead of TokenBigram, \"real\" "
"can match \"Is it really?\". But when you use TokenBigram, only \"really\" "
"can match as well."
msgstr ""
"TokenBigramではなくTokenBigramSplitSymbolAlphaを利用すると「Is it really?」に"
"「real」でマッチする。TokenBigramの場合は「really」でないとマッチしない。"

msgid ""
"It tokenise in bigram. In addition to TokenBigramSplitSymbolAlpha, "
"continuous numbers are not treated as a token either, but tokenised in "
"bigram. So any kind of characters are treated equally in bigram."
msgstr ""
"バイグラムでトークナイズする。TokenBigramSplitSymbolAlphaに加えて、連続した数"
"字も特別扱いせずに通常のバイグラムの処理を行う。つまり、すべての字種を特別扱"
"いせずにバイグラムの処理を行う。"

msgid "TokenBigramSplitSymbolAlphaDigit"
msgstr ""

msgid ""
"When you use TokenBigramSplitSymbolAlphaDigit instead of TokenBigram, "
"\"567\" can match \"090-0123-4567\". But when you use TokenBigram, only "
"\"4567\" can match as well."
msgstr ""
"TokenBigramではなくTokenBigramSplitSymbolAlphaDigitを利用すると"
"「090-0123-4567」に「567」でマッチする。TokenBigramの場合は「4567」でないと"
"マッチしない。"

msgid "It tokenise in bigram. Unlike TokenBigram, it ignores white spaces."
msgstr ""
"バイグラムでトークナイズする。TokenBigramと異なり、空白を無視して処理する。"

msgid "TokenBigramIgnoreBlank"
msgstr ""

msgid ""
"When you use TokenBigramIgnoreBlank instead of TokenBigram, \"みなさん\" can "
"match \"み な さ ん 注 目\". But when you use TokenBigram, only \"み な さ ん"
"\" can match as well."
msgstr ""
"TokenBigramではなくTokenBigramIgnoreBlankを利用すると「み な さ ん 注 目」に"
"「みなさん」でマッチする。TokenBigramの場合は「み な さ ん」でないとマッチし"
"ない。"

msgid ""
"It tokenise in bigram. Unlike TokenBigramSplitSymbol, it ignores white "
"spaces."
msgstr ""
"バイグラムでトークナイズする。TokenBigramSplitSymbolと異なり、空白を無視して"
"処理する。"

msgid "TokenBigramIgnoreBlankSplitSymbol"
msgstr ""

msgid ""
"When you use TokenBigramIgnoreBlankSplitSymbol instead of "
"TokenBigramSplitSymbol, \"???\" can match \"! ? ???\". But when you use "
"TokenBigramSplitSymbol, only \"? ??\" can match as well."
msgstr ""
"TokenBigramSplitSymbolではなくTokenBigramIgnoreBlankSplitSymbolを利用すると"
"「! !? ??」に「???」でマッチする。TokenBigramSplitSymbolの場合は「? ??」でな"
"いとマッチしない。"

msgid ""
"It tokenise in bigram. Unlike TokenBigramSplitSymbolAlpha, it ignores white "
"spaces."
msgstr ""
"バイグラムでトークナイズする。TokenBigramSplitSymbolAlphaと異なり、空白を無視"
"して処理する。"

msgid "TokenBigramIgnoreBlankSplitSymbolAlpha"
msgstr ""

msgid ""
"When you use TokenBigramIgnoreBlankSplitSymbolAlpha instead of "
"TokenBigramSplitSymbolAlpha, \"ama\" can match \"I am a pen.\". But when you "
"use TokenBigramSplitSymbolAlpha, only \"am a\" can match as well."
msgstr ""
"TokenBigramSplitSymbolAlphaではなくTokenBigramIgnoreBlankSplitSymbolAlphaを利"
"用すると「I am a pen.」に「ama」でマッチする。TokenBigramSplitSymbolAlphaの場"
"合は「am a」でないとマッチしない。"

msgid ""
"It tokenise in bigram. Unlike TokenBigramSplitSymbolAlphaDigit, it ignores "
"white spaces."
msgstr ""
"バイグラムでトークナイズする。TokenBigramSplitSymbolAlphaDigitと異なり、空白"
"を無視して処理する。"

msgid "TokenBigramIgnoreBlankSplitSymbolAlphaDigit"
msgstr ""

msgid ""
"When you use TokenBigramIgnoreBlankSplitSymbolAlphaDigit instead of "
"TokenBigramSplitSymbolAlphaDigit, \"9001\" can match \"090 0123 4567\". But "
"when you use TokenBigramSplitSymbolAlphaDigit, only \"90 01\" can match as "
"well."
msgstr ""
"okenBigramSplitSymbolAlphaDigitではなく"
"TokenBigramIgnoreBlankSplitSymbolAlphaDigitを利用すると「090 0123 4567」に"
"「9001」でマッチする。TokenBigramSplitSymbolAlphaDigitの場合は「90 01」でない"
"とマッチしない。"

msgid "It tokenise by splitting with a white space."
msgstr "空白区切りでトークナイズする。"

msgid ""
"\"movie horror topic\" will be tokenised as \"movie\", \"horror\", \"topic\"."
msgstr ""
"「movie horror topic」をトークナイズすると「movie」、「horror」、「topic」に"
"なります。"

msgid "TokenDelimit"
msgstr ""

msgid "It tokenise by splitting with a null character (\\\\0)."
msgstr "null文字（\\\\0）区切りでトークナイズする。"

msgid ""
"\"movie\\\\0horror\\\\0topic\" will be tokenised as \"movie\", \"horror\", "
"\"topic\"."
msgstr ""
"「movie\\\\0horror\\\\0topic」をトークナイズすると「movie」、「horror」、"
"「topic」になります。"

msgid "TokenDelimitNull"
msgstr ""

msgid ""
"It tokenises in unigram. But continuous alphabets, numbers or symbols are "
"treated as a token. So there can exist tokes with 2 letters or more. It is "
"to reduce noises."
msgstr ""
"ユニグラムでトークナイズする。ただし、連続したアルファベット・連続した数字・"
"連続した記号はそれぞれ1つのトークンとして扱う。そのため、2文字以上のトークン"
"も存在する。これはノイズを減らすためである。"

msgid "TokenUnigram"
msgstr ""

msgid ""
"It tokenises in trigram. But continuous alphabets, numbers or symbols are "
"treated as a token. So there can exist tokes with 4 letters or more. It is "
"to reduce noises."
msgstr ""
"トリグラムでトークナイズする。ただし、連続したアルファベット・連続した数字・"
"連続した記号はそれぞれ1つのトークンとして扱う。そのため、4文字以上のトークン"
"も存在する。これはノイズを減らすためである。"

msgid "TokenTrigram"
msgstr ""

msgid ""
"You can specify the default parser by passing ``--with-default-parser`` "
"option in ``configure`` when you build mroonga ::"
msgstr ""
"デフォルトのパーサは ``configure`` の ``--with-default-parser`` オプションで"
"ビルド時に指定することができます。::"

msgid ""
"Or you can set ``mroonga_default_parser`` variable in my.cnf or by SQL. If "
"you specify it in my.cnf, the change will not be lost after restarting "
"MySQL, but you need to restart MySQL to make it effective. On the other "
"hand, if you set it in SQL, the change is effective immediately, but it will "
"be lost when you restart MySQL."
msgstr ""
"また、my.cnfまたはSQL内で ``mroonga_default_parser`` 変数を指定することでも指"
"定できます。my.cnfで指定するとMySQLを再起動しても値は変更されたままですが、反"
"映させるために再起動しなければいけません。一方、SQLで指定した場合はすぐに設定"
"が反映されますが、MySQLが再起動すると設定は失われます。"

msgid "my.cnf::"
msgstr ""

msgid "SQL::"
msgstr ""

msgid "How to use geolocation search"
msgstr "位置情報検索の利用方法"

msgid ""
"In storage mode, you can use fast geolocation search in addition to full "
"text search. But unlike MyISAM, you can only store POINT type data. You "
"cannot store other types data like LINE. And fast search using index only "
"supports MBRContains. It does not support MBRDisjoint."
msgstr ""
"ストレージモードでは全文検索だけではなく位置情報検索も高速に実行できます。た"
"だし、MyISAMとは異なりデータとして格納できるのはPOINT型のみです。LINEなどの他"
"のデータ型は保存できません。また、インデックスを用いた高速な検索に対応してい"
"るのはMBRContainsだけです。MBRDisjointなどには対応していません。"

msgid ""
"For the table definition for geolocation search, you need to define a POINT "
"type column like in MyISAM and define SPATIAL INDEX for it. ::"
msgstr ""
"位置情報検索を利用する場合のテーブル定義はMyISAMと同様にPOINT型のカラムを定義"
"し、そのカラムに対してSPATIAL INDEXを指定します。::"

msgid ""
"To store data, you create POINT type data by using geomFromText() function "
"like in MyISAM. ::"
msgstr ""
"データの登録方法もMyISAMのときと同様にGeomFromText()関数を使って文字列から"
"POINT型の値を作成します。::"

msgid ""
"If you want to find shops within the rectangle where Ikebukuro station "
"(139.7101 35.7292) is the top-left point and Tokyo Station (139.7662 "
"35.6815) is the bottom-right point, SELECT phrase is like the following. ::"
msgstr ""
"池袋駅（139.7101 35.7292）が左上の点、東京駅（139.7662 35.6815）が右下の点と"
"なるような長方形内にあるお店を探す場合は以下のようなSELECTになります。::"

msgid "Here you can search by geolocation!"
msgstr "位置情報で検索できていますね！"

msgid "How to get the record ID"
msgstr "レコードIDの取得方法"

msgid ""
"Groonga assigns a unique number to identify the record when a record is "
"added in the table."
msgstr ""
"Groongaではテーブルにレコードを追加した際にレコードを一意に識別するための番号"
"が割当てられます。"

msgid ""
"To make the development of applications easier, you can get this record ID "
"by SQL in Mroonga"
msgstr ""
"Mroongaではアプリケーションの開発を容易にするため、このレコードIDをSQLで取得"
"できるようになっています。"

msgid ""
"To get the record ID, you need to create a column named ``_id`` when you "
"create a table. ::"
msgstr ""
"レコードIDを取得するためには、テーブル定義時に ``_id`` という名前のカラムを作"
"成して下さい。 ::"

msgid ""
"Tye typo of _id column should be integer one (TINYINT, SMALLINT, MEDIUMINT, "
"INT or BIGINT)."
msgstr ""
"_idカラムのデータ型は整数型(TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT)である"
"必要があります。"

msgid "You can create an index for _id column, but it should be HASH type."
msgstr ""
"また_idカラムにはインデックスを作成することが可能ですが、HASH形式である必要が"
"あります。"

msgid ""
"Let's add records in the table by INSERT. Since _id column is implemented as "
"a virtual column and its value is assigned by Groonga, you cannot specify "
"the value when updating. So you need to exclude it from setting columns, or "
"you need to use ``null`` as its value. ::"
msgstr ""
"INSERTでテーブルにレコードを追加してみましょう。_idカラムは仮想カラムとして実"
"装されており、また_idの値であるレコードIDはGroongaにより割当てられるため、SQL"
"による更新時に値を指定することはできません。更新対象から外すか、値に "
"``null`` を使用する必要があります。 ::"

msgid "To get the record ID, you invoke SELECT with _id column. ::"
msgstr ""
"レコードIDを取得するには、_idカラムを含むようにしてSELECTを行います。 ::"

msgid ""
"By using last_insert_grn_id function, you can also get the record ID that is "
"assigned by the last INSERT. ::"
msgstr ""
"また直前のINSERTにより割当てられたレコードIDについては、last_insert_grn_id関"
"数により取得することもできます。 ::"

msgid ""
"last_insert_grn_id function is included in Mroonga as a User-Defined "
"Function (UDF), but if you have not yet register it in MySQL by CREATE "
"FUNCTION, you need to invoke the following SQL for defining a function. ::"
msgstr ""
"last_insert_grn_id関数はユーザ定義関数(UDF)としてMroongaに含まれていますが、"
"インストール時にCREATE FUNCTIONでMySQLに追加していない場合には、以下の関数定"
"義DDLを実行しておく必要があります。 ::"

msgid ""
"As you can see in the example above, you can get the record ID by _id column "
"or last_insert_grn_id function. It will be useful to use this value in the "
"ensuing SQL queries like UPDATE. ::"
msgstr ""
"ご覧のように_idカラムやlast_insert_grn_id関数を通じてレコードIDを取得すること"
"ができました。ここで取得したレコードIDは後続のUPDATEなどのSQL文で利用すると便"
"利です。 ::"

msgid "How to get snippet (Keyword in context)"
msgstr "スニペット（キーワード周辺のテキスト）の取得方法"

msgid ""
"Mroonga provides functionality to get keyword in context. It is implemented "
"as 'mroonga_snippet' UDF."
msgstr ""

msgid "See :doc:`/reference/udf/mroonga_snippet` about details."
msgstr "詳細は :doc:`/reference/udf/mroonga_snippet` を参照してください。"

msgid "How to run Groonga command"
msgstr "Groongaコマンドの実行方法"

msgid ""
"In storage mode, Mroonga stores all your data into Groonga database. You can "
"access Groonga database by SQL with Mroonga. SQL is very powerful but it is "
"not good for some operations such as faceted search."
msgstr ""
"ストレージモードではMroongaはすべてのデータをGroongaのデータベースに保存しま"
"す。Mroongaを使うことでSQLでGroongaのデータベースにアクセスできるようになりま"
"す。SQLはとても強力ですが、ファセット検索などのようないくつかの操作が得意では"
"ありません。"

msgid ""
"Faceted search is popular recently. Many online shopping sites such as "
"amazon.com and ebay.com support faceted search. Faceted search refines the "
"current search by available search parameters before users refine their "
"search. And faceted search shows refined searches. Users just select a "
"refined search. Users benefit from faceted search:"
msgstr ""
"最近ではファセット検索は一般的なものになりました。amazon.comやebay.comのよう"
"に多くのオンラインショッピングサイトがファセット検索をサポートしています。"
"ファセット検索はユーザが検索結果を絞り込む前に絞り込み検索をし、その絞り込み"
"検索の結果を表示します。ユーザは絞りこまれた結果から自分が探しているものを選"
"ぶだけです。ファセット検索を使うとユーザは以下のようなメリットがあります。"

msgid ""
"Users don't need to think about how to refine their search. Users just "
"select a showed refined search."
msgstr ""
"ユーザはどうやって検索結果を絞り込むかを考える必要はありません。単に表示され"
"た絞り込み結果から選ぶだけです。"

msgid ""
"Users don't get boared \"not match\" page. Faceted search showes only "
"refined searches that has one or more matched items."
msgstr ""
"ユーザは「見つかりませんでした」ページを見ることがありません。ファセット検索"
"では絞り込んだ結果のうち、ヒットする項目がある結果だけを表示します。"

msgid ""
"Faceted search needs multiple `GROUP BY` operations against searched result "
"set. To do faceted search by SQL, multiple `SELECT` requests are needed. It "
"is not effective."
msgstr ""
"絞り込み検索は検索結果に対して複数の `GROUP BY` 操作を実行する必要がありま"
"す。SQLでファセット検索をやろうとすると、複数の `SELECT` リクエストが必要にな"
"ります。これは効率的ではありません。"

msgid ""
"Groonga can do faceted search by only one groonga command. It is effective. "
"Groonga has the `select` command that can search records with faceted "
"search. Faceted search is called as `drilldown` in Groonga. See `Groonga's "
"document <http://groonga.org/docs/reference/commands/select.html>`_ about "
"Groonga's `select` command."
msgstr ""
"Groongaは1回のgroongaコマンドでファセット検索をできます。これは効率的です。"
"Groongaには `select` コマンドというファセット検索に対応した検索コマンドがあり"
"ます。Groongaではファセット検索は `ドリルダウン（drilldown）` と呼ばれていま"
"す。Groongaの `select` コマンドの詳細については `Groongaのドキュメント "
"<http://groonga.org/ja/docs/reference/commands/select.html>`_ を参照してくだ"
"さい。"

msgid ""
"Mroonga provides `mroonga_command()` function. You can run groonga command "
"in SQL by the function. But you should use only `select` command. Other "
"commands that change schema or data may break consistency."
msgstr ""
"mroongaは `mroonga_command()` 関数を提供しています。この関数を使えばSQLの中で"
"好きなgroongaコマンドを実行できます。しかし、使うのは `select` コマンドだけに"
"しておくべきです。スキーマやデータを変更するコマンドを使うと一貫性が壊れてし"
"まうかもしれません。"

msgid "Here is the schema definition for execution examples::"
msgstr "実行例で使用するスキーマ定義はこちら::"

msgid "Here is the sample data for execution examples::"
msgstr "実行例で使用するサンプルデータはこちら::"

msgid ""
"Each record has `groonga` or `MySQL` as `tag`. Each record also has `year` "
"and `year_month`. You can use `tag`, `year` and `year_month` as faceted "
"search keys."
msgstr ""
"各レコードは `tag` として `groonga` と `MySQL` が付いています。各レコードは "
"`year` と `year_month` も持っています。ファセット検索のキーとして `tag` 、 "
"`year` 、 `year_month` を使えます。"

msgid ""
"Groonga calls faceted search as drilldown. So parameter key in Groonga is `--"
"drilldown`. Groonga returns search result as JSON. So `mroonga_command()` "
"also returns search result as JSON. It is not SQL friendly. You need to "
"parse search result JSON by yourself."
msgstr ""
"Groongaはファセット検索のことをドリルダウンと呼んでいます。そのため、Groonga"
"でのパラメータ名は `--drilldown` となっています。groongaは検索結果をJSONで返"
"します。そのため、 `mroonga_command()` も検索結果をJSONで返します。これはSQL"
"らしくありません。JSON形式の検索結果は自分でパースしないといけません。"

msgid ""
"Here is the example of faceted search by all available faceted search keys "
"(result JSON is pretty printted)::"
msgstr ""
"以下は利用可能なファセット検索キーをすべて使った例です。（結果のJSONは整形済"
"み）::"

msgid ""
"See `Groonga's select command document <http://groonga.org/docs/reference/"
"commands/select.html>`_ for more details."
msgstr ""
"詳細は `Groongaのselectコマンドのドキュメント <http://groonga.org/ja/docs/"
"reference/commands/select.html>`_ を確認してください。"

msgid "Logging"
msgstr "ログ出力"

msgid "Mroonga outputs the logs by default."
msgstr "Mroongaではデフォルトでログの出力を行うようになっています。"

msgid ""
"Log files are located in MySQL's data directory with the filename  ``groonga."
"log``."
msgstr ""
"ログファイルはMySQLのデータディレクトリ直下に ``groonga.log`` というファイル"
"名で出力されます。"

msgid "Here is the example of the log. ::"
msgstr "以下はログの出力例です。 ::"

msgid ""
"The default log level is NOTICE, i.e. we have important information only and "
"we don't have debug information etc.)."
msgstr ""
"ログのデフォルトの出力レベルはNOTICE（必要な情報のみ出力。デバッグ情報などは"
"出力しない）となっております。"

msgid ""
"You can get the log level by ``mroonga_log_level`` system variable, that is "
"a global variable. You can also modify it dynamically by using SET phrase. ::"
msgstr ""
"ログの出力レベルは ``mroonga_log_level`` というシステム変数で確認することがで"
"きます（グローバル変数）。またSET文で動的に出力レベルを変更することもできま"
"す。 ::"

msgid "Available log levels are the followings."
msgstr "設定可能なログレベルは以下の通りです。"

msgid "NONE"
msgstr ""

msgid "EMERG"
msgstr ""

msgid "ALERT"
msgstr ""

msgid "CRIT"
msgstr ""

msgid "ERROR"
msgstr ""

msgid "WARNING"
msgstr ""

msgid "NOTICE"
msgstr ""

msgid "INFO"
msgstr ""

msgid "DEBUG"
msgstr ""

msgid "DUMP"
msgstr ""

msgid "See :ref:`mroonga_log_level` about details."
msgstr "詳細は :ref:`mroonga_log_level` を参照してください。"

msgid ""
"You can reopen the log file by FLUSH LOGS. If you want to rotate the log "
"file without stopping MySQL server, you can do in the following procedure."
msgstr ""
"またFLUSH LOGSでログの再オープンを行うことができます。MySQLサーバを停止せずに"
"ログのローテートを行いたいような場合には、以下の手順で実行すると良いでしょ"
"う。"

msgid ""
"change the file name of ``groonga.log`` (by using OS's mv command etc.)."
msgstr "``groonga.log`` ファイルの名前を変更（OSコマンドのmvなどで）"

msgid ""
"invoke \"FLUSH LOGS\" in MySQL server (by mysql command or mysqladmin "
"command)."
msgstr ""
"MySQLサーバに対して\"FLUSH LOGS\"を実行（mysqlコマンドあるいはmysqladminコマ"
"ンドにて）"

msgid "Choosing appropriate columns"
msgstr "カラムの刈り込み"

msgid ""
"Groonga uses one file per column to store data, and Mroonga accesses needed "
"columns only when accessing a table to utilise this characteristic."
msgstr ""
"Groongaでは各カラムごとにファイルを分けてデータを格納する「カラムストア方式」"
"が採用されており、Mroongaではこの特性を活かすためにテーブルアクセス時に必要な"
"カラムに対してのみアクセスを行う実装を行っています。"

msgid ""
"This optimisation is done automatically in Mroonga internal, you don't need "
"any specific configuration."
msgstr ""
"この高速化の仕組みはMroonga内部で自動的に行われるため、特に設定などを行う必要"
"はありません。"

msgid "Imagine that we have a table with 20 columns like below. ::"
msgstr ""
"例えば以下のようにカラムが20個定義されているテーブルが存在するものと仮定しま"
"す。 ::"

msgid ""
"When we run SELECT phrase like the following, Mroonga reads data from "
"columns that are referred by SELECT phrase and WHERE phrase only (and it "
"does not access columns that not required internally)."
msgstr ""
"この時、以下のようなSELECT文が発行される場合、MroongaではSELECT句およびWHERE"
"句で参照しているカラムに対してのみデータの読み取りを行ってSQL文を処理します"
"（内部的に不要なカラムに対してはアクセスしません）。 ::"

msgid "SELECT c1, c2, c11 FROM t1 WHERE c2 = XX AND c12 = \"XXX\";"
msgstr ""

msgid ""
"In this case above, only columns c1, c2, c11 and c12 are accessed, and we "
"can process the SQL rapidly."
msgstr ""
"このケースではc1,c2,c11,c12に対してのみアクセスが行われ、SQL文が高速に処理さ"
"れることになります。"

msgid "Optimisation for counting rows"
msgstr "行カウント高速化"

msgid ""
"In MySQL's storage engine interface, there is no difference between counting "
"rows like COUNT(\\*) and normal data retrieving by SELECT. So access to data "
"that is not included in SELECT result can happen even if you just want to "
"count rows."
msgstr ""
"COUNT(\\*)などの行カウントを行う場合と通常のSELECTによるデータ参照を行う場合"
"に対して、従来よりMySQLではストレージエンジンの呼び出しを行う部分(=ストレージ"
"エンジンインタフェース)における区別が存在していないため、行数をカウントするだ"
"けで良いような場合にもレコードアクセス（SELECTの結果には含まれないデータへの"
"アクセス）が行われる問題があります。"

msgid ""
"Tritonn (MySQL + Senna), that is Mroonga's predecessor, introduced \"2ind "
"patch\" to skip needless access to data and solved this performance issue."
msgstr ""
"Mroongaの前身であるTritonn(MySQL+Senna)ではこの問題に対して\"2indパッチ\"とい"
"う不要なレコードアクセスを省略する仕組みを独自に実装してこの性能問題を回避し"
"ていました。"

msgid "Mroonga also has the optimisation for counting rows."
msgstr ""
"これに引き続き、Mroongaでも行カウントを高速化するための仕組みを実装していま"
"す。"

msgid ""
"In the following SELECT, for example, needless read of columns are skipped "
"and you can get the result of counting rows with the minimal cost."
msgstr ""
"例えば以下のSELECT文では不要なカラムデータの読み取りは省略され、必要最小限の"
"コストで行カウントの結果を返すことができます。 ::"

msgid "SELECT COUNT(*) FROM t1 WHERE MATCH(c2) AGAINST(\"hoge\");"
msgstr ""

msgid ""
"You can check if this optimisation works or not by the status variable. ::"
msgstr ""
"この最適化処理が行われたかどうかはステータス変数で確認することもできます。::"

msgid ""
"Each time the optimisation for counting rows works, ``Mroonga_count_skip`` "
"status variable value is increased."
msgstr ""
"行カウント高速化の処理が行われる度に ``Mroonga_count_skip`` ステータス変数が"
"インクリメントされます。"

msgid ""
"Note : This optimisation is implemented by using the index. It only works in "
"the case where we records can be specified only by the index."
msgstr ""
"備考：この高速化機能はインデックスを用いて実装されています。現在のところイン"
"デックスアクセスのみでレコードが特定できるパタンでのみ有効に機能します。"

msgid "Optimisation for ORDER BY LIMIT in full text search"
msgstr "全文検索時の ORDER BY LIMIT 高速化"

msgid ""
"Generally speaking, MySQL can process \"ORDER BY\" query with almost no cost "
"if we can get records by index, and can process \"LIMIT\" with low cost by "
"limiting the range of processing data even if the number of query result is "
"very big."
msgstr ""
"一般的にMySQLでは\"ORDER BY\"はインデックス経由のレコード参照が行えればほぼ"
"ノーコストで処理可能であり、\"LIMIT\"は検索結果が大量にヒットする場合でも処理"
"対象を限定することでコストを一定に抑える効果があります。"

msgid ""
"But for the query where \"ORDER BY\" cannot use index, like sort full text "
"search result by the score and use LIMIT, the processing cost is "
"proportional to the number of query results. So it might take very long time "
"for the keyword query that matches with many records."
msgstr ""
"しかし例えば全文検索のスコアの降順+LIMITのように\"ORDER BY\"の処理の際にイン"
"デックスが効かないクエリの場合、検索ヒット件数に比例したコストがかかってしま"
"うため、特に大量の検索がヒットするようなキーワード検索においてクエリ処理に極"
"端に時間がかかってしまうケースがあります。"

msgid ""
"Tritonn took no specific countermeasure for this issue, but it introduced a "
"workaround in the latest repository so that it sorted Senna result in "
"descending order of the score by using sen_records_sort function so that we "
"could remove ORDER BY from the SQL query."
msgstr ""
"Tritonnではこの問題に対して特に対応はできていませんでしたが、最新レポジトリで"
"はsen_records_sort関数を活用してSennaからの読み出しをスコアの降順に対応させる"
"ことでSQLクエリからORDER BY句を取り除く(※スコア降順を指定していたケースに対し"
"てのみ有効)回避方法を導入しました。"

msgid "Mroonga also has the optimisation for ORDER BY LIMIT."
msgstr "Mroongaでも ORDER BY LIMIT を高速化するための仕組みを実装しています。"

msgid ""
"In the SELECT example below, ORDER BY LIMIT is processed in groonga only and "
"the minimal records are passed to MySQL. ::"
msgstr ""
"例えば以下のSELECT文では ORDER BY LIMIT は、groonga内で処理され、必要最小限の"
"レコードだけをMySQLに返却しています。 ::"

msgid ""
"Each time the optimisation for counting rows works, "
"``Mroonga_fast_order_limit`` status variable value is increased."
msgstr ""
"ORDER BY LIMIT 高速化の処理が行われる度に ``Mroonga_fast_order_limit`` ステー"
"タス変数がインクリメントされます。"

msgid ""
"Note : This optimisation is targeting queries like \"select ... match "
"against order by _score desc limit X, Y\" only, and it works if all of the "
"following conditions are right."
msgstr ""
"備考：この高速化機能は、「select ... match against order by _score desc "
"limit X, Y」を狙い撃ちした高速化で、現在のところ以下の条件が成立した場合に機"
"能します。"

msgid "WHERE phrase has \"match...against\" only"
msgstr "where句がmatch...againstのみ"

msgid "no JOIN"
msgstr "joinしていない"

msgid "with LIMIT"
msgstr "limitの指定がある"

msgid ""
"ORDER BY phrase has columns (including _id) or \"match...against\" that is "
"used in WHERE phrase only"
msgstr ""
"order byの指定がカラム(_id含む)またはwhere句に指定したmatch...againstである"

msgid "Footnotes"
msgstr "脚注"

msgid ""
"`MySQL 5.1 Reference Manual :: 11 Functions and Operations :: 11.7 Full-Text "
"Search Functions <http://dev.mysql.com/doc/refman/5.1/ja/fulltext-search."
"html>`_"
msgstr ""
"`MySQL 5.1 リファレンスマニュアル :: 11 関数と演算子 :: 11.7 全文検索関数 "
"<http://dev.mysql.com/doc/refman/5.1/ja/fulltext-search.html>`_"

msgid "In groonga, we call it a 'tokenizer'."
msgstr "Groongaではトークナイザーと呼んでいる。"

msgid "Wrapper mode"
msgstr "ラッパーモード"

msgid "Here we explain how to use wrapper mode of Mroonga"
msgstr "ここでは Mroonga におけるラッパーモードの利用方法を説明します。"

msgid "How to use wrapper mode"
msgstr "ラッパーモードの利用方法"

msgid ""
"In wrapper mode, Mroonga works in wrapping an existing storage engine. To "
"specify the wrapped storage engine, we use SQL comment like ``COMMENT = "
"'engine \"InnoDB\"'`` for now."
msgstr ""
"ラッパーモードでは、既存のストレージエンジンをラップするかたちで Mroonga が動"
"作します。ラップする対象となるストレージエンジンは、現在のところ SQL のコメン"
"トを利用して ``COMMENT = 'engine \"InnoDB\"'`` のように指定するようになってい"
"ます。"

msgid ""
"For now, a primary key is mandatory in wrapper mode. That is not the case "
"with storage mode."
msgstr ""
"現在のところ、ラッパーモードではテーブルに必ずプライマリーキーを設定する必要"
"があります。ストレージモードはこの限りではありません。"

msgid ""
"Wrapper mode supports the followings, that are not supported in storage mode "
"for now."
msgstr ""
"ラッパーモードでは現在ストレージモードでサポートされていない、以下をサポート"
"しています。"

msgid "null value"
msgstr "null値"

msgid ""
"transaction (if storage engine supports. Note that rollback causes mismatch "
"of indexes, it may affects search results, so recreate index of Mroonga in "
"such a case.)"
msgstr ""
"トランザクション (ストレージエンジンがサポートしている場合。ロールバックする"
"とインデックスの不整合が発生します。インデックスを使った検索に影響するので、"
"その場合にはMroongaのインデックスを再作成します。)"

msgid ""
"You can specify the default parser by passing ``--with-default-parser`` "
"option in ``configure`` when you build Mroonga. ::"
msgstr ""
"デフォルトのパーサは ``configure`` の ``--with-default-parser`` オプションで"
"ビルド時に指定することができます。::"

msgid ""
"In the SELECT example below, ORDER BY LIMIT is processed in Mroonga only and "
"the minimal records are passed to MySQL. ::"
msgstr ""
"例えば以下のSELECT文では ORDER BY LIMIT は、Mroonga内で処理され、必要最小限の"
"レコードだけをMySQLに返却しています。 ::"

msgid ""
"Each time the optimisation for counting rows works, "
"``mroonga_fast_order_limit`` status variable value is increased."
msgstr ""
"ORDER BY LIMIT 高速化の処理が行われる度に ``Mroonga_fast_order_limit`` ステー"
"タス変数がインクリメントされます。"

msgid ""
"ORDER BY phrase has _id column or \"match...against\" that is used in WHERE "
"phrase only"
msgstr ""
"order byの指定がカラム(_id含む)またはwhere句に指定したmatch...againstである"

msgid "In Groonga, we call it a 'tokenizer'."
msgstr "Groongaではトークナイザーと呼んでいる。"
