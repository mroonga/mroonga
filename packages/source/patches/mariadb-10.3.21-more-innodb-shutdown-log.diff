--- mariadb-10.3.20/storage/innobase/srv/srv0start.cc	2019-11-07 01:01:58.000000000 +0900
+++ mariadb-10.3.20.patch/storage/innobase/srv/srv0start.cc	2019-12-11 16:54:29.228377261 +0900
@@ -2537,6 +2537,7 @@ void srv_shutdown_bg_undo_sources()
 /** Shut down InnoDB. */
 void innodb_shutdown()
 {
+	ib::info() << "Shutdown started; operation " << srv_operation;
 	ut_ad(!my_atomic_loadptr_explicit(reinterpret_cast<void**>
 					  (&srv_running),
 					  MY_MEMORY_ORDER_RELAXED));
@@ -2547,12 +2548,15 @@ void innodb_shutdown()
 	case SRV_OPERATION_RESTORE:
 	case SRV_OPERATION_RESTORE_DELTA:
 	case SRV_OPERATION_RESTORE_EXPORT:
+		ib::info() << "fil_close_all_files() started";
 		fil_close_all_files();
+		ib::info() << "fil_close_all_files() completed";
 		break;
 	case SRV_OPERATION_NORMAL:
 		/* Shut down the persistent files. */
+		ib::info() << "logs_empty_and_mark_files_at_shutdown() started";
 		logs_empty_and_mark_files_at_shutdown();
-
+		ib::info() << "logs_empty_and_mark_files_at_shutdown() completed";
 		if (ulint n_threads = srv_conc_get_active_threads()) {
 			ib::warn() << "Query counter shows "
 				   << n_threads << " queries still"
@@ -2561,20 +2565,26 @@ void innodb_shutdown()
 	}
 
 	/* Exit any remaining threads. */
+	ib::info() << "srv_shutdown_all_bg_threads() started";
 	srv_shutdown_all_bg_threads();
+	ib::info() << "srv_shutdown_all_bg_threads() completed";
 
 	if (srv_monitor_file) {
+		ib::info() << "close srv_monitor_file started";
 		fclose(srv_monitor_file);
 		srv_monitor_file = 0;
 		if (srv_monitor_file_name) {
 			unlink(srv_monitor_file_name);
 			ut_free(srv_monitor_file_name);
 		}
+		ib::info() << "close srv_monitor_file completed";
 	}
 
 	if (srv_misc_tmpfile) {
+		ib::info() << "close srv_misc_tmpfile started";
 		fclose(srv_misc_tmpfile);
 		srv_misc_tmpfile = 0;
+		ib::info() << "close srv_misc_tmpfile completed";
 	}
 
 	ut_ad(dict_stats_event || !srv_was_started || srv_read_only_mode);
@@ -2590,7 +2600,9 @@ void innodb_shutdown()
 	ut_ad(ibuf || !srv_was_started);
 
 	if (dict_stats_event) {
+		ib::info() << "dict_stats_thread_deinit() started";
 		dict_stats_thread_deinit();
+		ib::info() << "dict_stats_thread_deinit() completed";
 	}
 
 	if (srv_start_state_is_set(SRV_START_STATE_REDO)) {
@@ -2598,9 +2610,15 @@ void innodb_shutdown()
 		/* srv_shutdown_bg_undo_sources() already invoked
 		fts_optimize_shutdown(); dict_stats_shutdown(); */
 
+		ib::info() << "fil_crypt_threads_cleanup() started";
 		fil_crypt_threads_cleanup();
+		ib::info() << "fil_crypt_threads_cleanup() completed";
+		ib::info() << "btr_scrub_cleanup() started";
 		btr_scrub_cleanup();
+		ib::info() << "btr_scrub_cleanup() completed";
+		ib::info() << "btr_defragment_shutdown() started";
 		btr_defragment_shutdown();
+		ib::info() << "btr_defragment_shutdown() completed";
 	}
 
 	/* This must be disabled before closing the buffer pool
@@ -2608,47 +2626,91 @@ void innodb_shutdown()
 
 #ifdef BTR_CUR_HASH_ADAPT
 	if (dict_sys) {
+		ib::info() << "btr_search_disable() started";
 		btr_search_disable(true);
+		ib::info() << "btr_search_disable() completed";
 	}
 #endif /* BTR_CUR_HASH_ADAPT */
 	if (ibuf) {
+		ib::info() << "ibuf_close() started";
 		ibuf_close();
+		ib::info() << "ibuf_close() completed";
 	}
+	ib::info() << "log_sys.close() started";
 	log_sys.close();
+	ib::info() << "log_sys.close() completed";
+	ib::info() << "purge_sys.close() started";
 	purge_sys.close();
+	ib::info() << "purge_sys.close() completed";
+	ib::info() << "trx_sys.close() started";
 	trx_sys.close();
+	ib::info() << "trx_sys.close() completed";
 	if (buf_dblwr) {
+		ib::info() << "buf_dblwr_free() started";
 		buf_dblwr_free();
+		ib::info() << "buf_dblwr_free() completed";
 	}
+	ib::info() << "lock_sys.close() started";
 	lock_sys.close();
+	ib::info() << "lock_sys.close() completed";
+	ib::info() << "trx_pool.close() started";
 	trx_pool_close();
+	ib::info() << "trx_pool.close() completed";
 
 	if (!srv_read_only_mode) {
+		ib::info() << "srv_monitor_file_mutex free started";
 		mutex_free(&srv_monitor_file_mutex);
+		ib::info() << "srv_monitor_file_mutex free completed";
+		ib::info() << "srv_misc_tmpfile_mutex free started";
 		mutex_free(&srv_misc_tmpfile_mutex);
+		ib::info() << "srv_misc_tmpfile_mutex free completed";
 	}
 
+	ib::info() << "dict_close() started";
 	dict_close();
+	ib::info() << "dict_close() completed";
+	ib::info() << "btr_search_sys_free() started";
 	btr_search_sys_free();
+	ib::info() << "btr_search_sys_free() started";
 
 	/* 3. Free all InnoDB's own mutexes and the os_fast_mutexes inside
 	them */
+	ib::info() << "free all InnoDB's own mutexes started";
+	ib::info() << "os_aio_free() started";
 	os_aio_free();
+	ib::info() << "os_aio_free() completed";
+	ib::info() << "row_mysql_close() started";
 	row_mysql_close();
+	ib::info() << "row_mysql_close() completed";
+	ib::info() << "srv_free() started";
 	srv_free();
+	ib::info() << "srv_free() completed";
+	ib::info() << "fil_system.close() started";
 	fil_system.close();
+	ib::info() << "fil_system.close() completed";
+	ib::info() << "free all InnoDB's own mutexes completed";
 
 	/* 4. Free all allocated memory */
 
+	ib::info() << "free all allocated memory started";
+	ib::info() << "pars_lexer_close() started";
 	pars_lexer_close();
+	ib::info() << "pars_lexer_close() completed";
+	ib::info() << "recv_sys_close() started";
 	recv_sys_close();
+	ib::info() << "recv_sys_close() completed";
 
 	ut_ad(buf_pool_ptr || !srv_was_started);
 	if (buf_pool_ptr) {
+		ib::info() << "buf_pool_free() started";
 		buf_pool_free(srv_buf_pool_instances);
+		ib::info() << "buf_pool_free() completed";
 	}
 
+	ib::info() << "sync_check_close() started";
 	sync_check_close();
+	ib::info() << "sync_check_close() completed";
+	ib::info() << "free all allocated memory completed";
 
 	if (srv_was_started && srv_print_verbose_log) {
 		ib::info() << "Shutdown completed; log sequence number "
